
import torch
import torch.nn as nn

class HyperNetwork(nn.Module):
    """
    A simple hypernetwork that generates weights for another network.
    """
    def __init__(self, input_dim, output_dim, hidden_dim=64):
        super(HyperNetwork, self).__init__()
        self.input_dim = input_dim
        self.output_dim = output_dim
        self.hidden_dim = hidden_dim

        self.network = nn.Sequential(
            nn.Linear(self.input_dim, self.hidden_dim),
            nn.ReLU(),
            nn.Linear(self.hidden_dim, self.output_dim)
        )

    def forward(self, x):
        """
        Generates weights based on the input.
        """
        return self.network(x)

class HyperLinear(nn.Module):
    """
    A linear layer whose weights are generated by a hypernetwork.
    """
    def __init__(self, hypernetwork, input_features, output_features):
        super(HyperLinear, self).__init__()
        self.hypernetwork = hypernetwork
        self.input_features = input_features
        self.output_features = output_features

        # The hypernetwork needs to generate weights for the linear layer
        # The size of the weights is (output_features, input_features)
        # The size of the bias is (output_features)
        self.weight_size = output_features * input_features
        self.bias_size = output_features
        
        # The hypernetwork's output dimension must match the total size of the weights and bias
        assert self.hypernetwork.output_dim == self.weight_size + self.bias_size

    def forward(self, x, z):
        """
        Performs a forward pass using the generated weights.
        x: The input to the linear layer.
        z: The input to the hypernetwork.
        """
        # Generate the weights and bias from the hypernetwork
        params = self.hypernetwork(z)
        
        # Split the generated parameters into weights and bias
        weights = params[:, :self.weight_size].reshape(-1, self.output_features, self.input_features)
        bias = params[:, self.weight_size:].reshape(-1, self.output_features)

        # Apply the linear transformation
        # We need to handle the batch dimension
        output = torch.bmm(weights, x.unsqueeze(2)).squeeze(2) + bias
        return output
